// This client was generated by Platformatic from an OpenAPI specification.

// The base URL for the API. This can be overridden by calling `setBaseUrl`.
let baseUrl = ''
// The default headers to send within each request. This can be overridden by calling `setDefaultHeaders`.
let defaultHeaders = {}

function sanitizeUrl(url) {
  if (url.endsWith('/')) { return url.slice(0, -1) } else { return url }
}
/**  @type {import('./api-types.d.ts').Api['setBaseUrl']} */
export const setBaseUrl = (newUrl) => { baseUrl = sanitizeUrl(newUrl) }

/**  @type {import('./api-types.d.ts').Api['setDefaultHeaders']} */
export const setDefaultHeaders = (headers) => { defaultHeaders = headers }

function headersToJSON(headers) {
  const output = {}
  headers.forEach((value, key) => {
    output[key] = value
  })
  return output
}

async function _entityGetRoles (url, request) {
  const queryParameters = ['limit', 'offset', 'totalCount', 'fields', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.name.eq', 'where.name.neq', 'where.name.gt', 'where.name.gte', 'where.name.lt', 'where.name.lte', 'where.name.like', 'where.name.in', 'where.name.nin', 'where.name.contains', 'where.name.contained', 'where.name.overlaps', 'where.or', 'orderby.createdAt', 'orderby.id', 'orderby.name']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/roles/?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetRoles']} */
export const entityGetRoles = async (request) => {
  return await _entityGetRoles(baseUrl, request)
}
async function _entityCreateRole (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/entity/roles/`, {
    method: 'POST',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityCreateRole']} */
export const entityCreateRole = async (request) => {
  return await _entityCreateRole(baseUrl, request)
}
async function _entityUpdateRoles (url, request) {
  const queryParameters = ['fields', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.name.eq', 'where.name.neq', 'where.name.gt', 'where.name.gte', 'where.name.lt', 'where.name.lte', 'where.name.like', 'where.name.in', 'where.name.nin', 'where.name.contains', 'where.name.contained', 'where.name.overlaps', 'where.or']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/entity/roles/?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityUpdateRoles']} */
export const entityUpdateRoles = async (request) => {
  return await _entityUpdateRoles(baseUrl, request)
}
async function _entityGetRoleById (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/roles/${request['id']}?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetRoleById']} */
export const entityGetRoleById = async (request) => {
  return await _entityGetRoleById(baseUrl, request)
}
async function _entityUpdateRole (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/entity/roles/${request['id']}?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityUpdateRole']} */
export const entityUpdateRole = async (request) => {
  return await _entityUpdateRole(baseUrl, request)
}
async function _entityDeleteRoles (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/entity/roles/${request['id']}?${searchParams.toString()}`, {
    method: 'DELETE',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityDeleteRoles']} */
export const entityDeleteRoles = async (request) => {
  return await _entityDeleteRoles(baseUrl, request)
}
async function _entityGetUsersForRole (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/roles/${request['id']}/users?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetUsersForRole']} */
export const entityGetUsersForRole = async (request) => {
  return await _entityGetUsersForRole(baseUrl, request)
}
async function _entityGetUsers (url, request) {
  const queryParameters = ['limit', 'offset', 'totalCount', 'fields', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.fullName.eq', 'where.fullName.neq', 'where.fullName.gt', 'where.fullName.gte', 'where.fullName.lt', 'where.fullName.lte', 'where.fullName.like', 'where.fullName.in', 'where.fullName.nin', 'where.fullName.contains', 'where.fullName.contained', 'where.fullName.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.password.eq', 'where.password.neq', 'where.password.gt', 'where.password.gte', 'where.password.lt', 'where.password.lte', 'where.password.like', 'where.password.in', 'where.password.nin', 'where.password.contains', 'where.password.contained', 'where.password.overlaps', 'where.role.eq', 'where.role.neq', 'where.role.gt', 'where.role.gte', 'where.role.lt', 'where.role.lte', 'where.role.like', 'where.role.in', 'where.role.nin', 'where.role.contains', 'where.role.contained', 'where.role.overlaps', 'where.username.eq', 'where.username.neq', 'where.username.gt', 'where.username.gte', 'where.username.lt', 'where.username.lte', 'where.username.like', 'where.username.in', 'where.username.nin', 'where.username.contains', 'where.username.contained', 'where.username.overlaps', 'where.or', 'orderby.createdAt', 'orderby.fullName', 'orderby.id', 'orderby.password', 'orderby.role', 'orderby.username']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/users/?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetUsers']} */
export const entityGetUsers = async (request) => {
  return await _entityGetUsers(baseUrl, request)
}
async function _entityCreateUser (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/entity/users/`, {
    method: 'POST',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityCreateUser']} */
export const entityCreateUser = async (request) => {
  return await _entityCreateUser(baseUrl, request)
}
async function _entityUpdateUsers (url, request) {
  const queryParameters = ['fields', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.fullName.eq', 'where.fullName.neq', 'where.fullName.gt', 'where.fullName.gte', 'where.fullName.lt', 'where.fullName.lte', 'where.fullName.like', 'where.fullName.in', 'where.fullName.nin', 'where.fullName.contains', 'where.fullName.contained', 'where.fullName.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.password.eq', 'where.password.neq', 'where.password.gt', 'where.password.gte', 'where.password.lt', 'where.password.lte', 'where.password.like', 'where.password.in', 'where.password.nin', 'where.password.contains', 'where.password.contained', 'where.password.overlaps', 'where.role.eq', 'where.role.neq', 'where.role.gt', 'where.role.gte', 'where.role.lt', 'where.role.lte', 'where.role.like', 'where.role.in', 'where.role.nin', 'where.role.contains', 'where.role.contained', 'where.role.overlaps', 'where.username.eq', 'where.username.neq', 'where.username.gt', 'where.username.gte', 'where.username.lt', 'where.username.lte', 'where.username.like', 'where.username.in', 'where.username.nin', 'where.username.contains', 'where.username.contained', 'where.username.overlaps', 'where.or']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/entity/users/?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityUpdateUsers']} */
export const entityUpdateUsers = async (request) => {
  return await _entityUpdateUsers(baseUrl, request)
}
async function _entityGetUserById (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/users/${request['id']}?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetUserById']} */
export const entityGetUserById = async (request) => {
  return await _entityGetUserById(baseUrl, request)
}
async function _entityUpdateUser (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/entity/users/${request['id']}?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityUpdateUser']} */
export const entityUpdateUser = async (request) => {
  return await _entityUpdateUser(baseUrl, request)
}
async function _entityDeleteUsers (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/entity/users/${request['id']}?${searchParams.toString()}`, {
    method: 'DELETE',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityDeleteUsers']} */
export const entityDeleteUsers = async (request) => {
  return await _entityDeleteUsers(baseUrl, request)
}
async function _entityGetExamsForUser (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/users/${request['id']}/exams?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetExamsForUser']} */
export const entityGetExamsForUser = async (request) => {
  return await _entityGetExamsForUser(baseUrl, request)
}
async function _entityGetExamineeExamsForUser (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/users/${request['id']}/examineeExamExamineeId?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetExamineeExamsForUser']} */
export const entityGetExamineeExamsForUser = async (request) => {
  return await _entityGetExamineeExamsForUser(baseUrl, request)
}
async function _entityGetRoleForUser (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/users/${request['id']}/role?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetRoleForUser']} */
export const entityGetRoleForUser = async (request) => {
  return await _entityGetRoleForUser(baseUrl, request)
}
async function _entityGetExams (url, request) {
  const queryParameters = ['limit', 'offset', 'totalCount', 'fields', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.createdBy.eq', 'where.createdBy.neq', 'where.createdBy.gt', 'where.createdBy.gte', 'where.createdBy.lt', 'where.createdBy.lte', 'where.createdBy.like', 'where.createdBy.in', 'where.createdBy.nin', 'where.createdBy.contains', 'where.createdBy.contained', 'where.createdBy.overlaps', 'where.description.eq', 'where.description.neq', 'where.description.gt', 'where.description.gte', 'where.description.lt', 'where.description.lte', 'where.description.like', 'where.description.in', 'where.description.nin', 'where.description.contains', 'where.description.contained', 'where.description.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.status.eq', 'where.status.neq', 'where.status.gt', 'where.status.gte', 'where.status.lt', 'where.status.lte', 'where.status.like', 'where.status.in', 'where.status.nin', 'where.status.contains', 'where.status.contained', 'where.status.overlaps', 'where.title.eq', 'where.title.neq', 'where.title.gt', 'where.title.gte', 'where.title.lt', 'where.title.lte', 'where.title.like', 'where.title.in', 'where.title.nin', 'where.title.contains', 'where.title.contained', 'where.title.overlaps', 'where.or', 'orderby.createdAt', 'orderby.createdBy', 'orderby.description', 'orderby.id', 'orderby.status', 'orderby.title']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/exams/?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetExams']} */
export const entityGetExams = async (request) => {
  return await _entityGetExams(baseUrl, request)
}
async function _entityCreateExam (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/entity/exams/`, {
    method: 'POST',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityCreateExam']} */
export const entityCreateExam = async (request) => {
  return await _entityCreateExam(baseUrl, request)
}
async function _entityUpdateExams (url, request) {
  const queryParameters = ['fields', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.createdBy.eq', 'where.createdBy.neq', 'where.createdBy.gt', 'where.createdBy.gte', 'where.createdBy.lt', 'where.createdBy.lte', 'where.createdBy.like', 'where.createdBy.in', 'where.createdBy.nin', 'where.createdBy.contains', 'where.createdBy.contained', 'where.createdBy.overlaps', 'where.description.eq', 'where.description.neq', 'where.description.gt', 'where.description.gte', 'where.description.lt', 'where.description.lte', 'where.description.like', 'where.description.in', 'where.description.nin', 'where.description.contains', 'where.description.contained', 'where.description.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.status.eq', 'where.status.neq', 'where.status.gt', 'where.status.gte', 'where.status.lt', 'where.status.lte', 'where.status.like', 'where.status.in', 'where.status.nin', 'where.status.contains', 'where.status.contained', 'where.status.overlaps', 'where.title.eq', 'where.title.neq', 'where.title.gt', 'where.title.gte', 'where.title.lt', 'where.title.lte', 'where.title.like', 'where.title.in', 'where.title.nin', 'where.title.contains', 'where.title.contained', 'where.title.overlaps', 'where.or']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/entity/exams/?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityUpdateExams']} */
export const entityUpdateExams = async (request) => {
  return await _entityUpdateExams(baseUrl, request)
}
async function _entityGetExamById (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/exams/${request['id']}?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetExamById']} */
export const entityGetExamById = async (request) => {
  return await _entityGetExamById(baseUrl, request)
}
async function _entityUpdateExam (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/entity/exams/${request['id']}?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityUpdateExam']} */
export const entityUpdateExam = async (request) => {
  return await _entityUpdateExam(baseUrl, request)
}
async function _entityDeleteExams (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/entity/exams/${request['id']}?${searchParams.toString()}`, {
    method: 'DELETE',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityDeleteExams']} */
export const entityDeleteExams = async (request) => {
  return await _entityDeleteExams(baseUrl, request)
}
async function _entityGetQuestionsForExam (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/exams/${request['id']}/questions?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetQuestionsForExam']} */
export const entityGetQuestionsForExam = async (request) => {
  return await _entityGetQuestionsForExam(baseUrl, request)
}
async function _entityGetExamineeExamsForExam (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/exams/${request['id']}/examineeExamExamId?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetExamineeExamsForExam']} */
export const entityGetExamineeExamsForExam = async (request) => {
  return await _entityGetExamineeExamsForExam(baseUrl, request)
}
async function _entityGetUserForExam (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/exams/${request['id']}/created_by?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetUserForExam']} */
export const entityGetUserForExam = async (request) => {
  return await _entityGetUserForExam(baseUrl, request)
}
async function _entityGetQuestions (url, request) {
  const queryParameters = ['limit', 'offset', 'totalCount', 'fields', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.description.eq', 'where.description.neq', 'where.description.gt', 'where.description.gte', 'where.description.lt', 'where.description.lte', 'where.description.like', 'where.description.in', 'where.description.nin', 'where.description.contains', 'where.description.contained', 'where.description.overlaps', 'where.examId.eq', 'where.examId.neq', 'where.examId.gt', 'where.examId.gte', 'where.examId.lt', 'where.examId.lte', 'where.examId.like', 'where.examId.in', 'where.examId.nin', 'where.examId.contains', 'where.examId.contained', 'where.examId.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.status.eq', 'where.status.neq', 'where.status.gt', 'where.status.gte', 'where.status.lt', 'where.status.lte', 'where.status.like', 'where.status.in', 'where.status.nin', 'where.status.contains', 'where.status.contained', 'where.status.overlaps', 'where.title.eq', 'where.title.neq', 'where.title.gt', 'where.title.gte', 'where.title.lt', 'where.title.lte', 'where.title.like', 'where.title.in', 'where.title.nin', 'where.title.contains', 'where.title.contained', 'where.title.overlaps', 'where.or', 'orderby.createdAt', 'orderby.description', 'orderby.examId', 'orderby.id', 'orderby.status', 'orderby.title']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/questions/?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetQuestions']} */
export const entityGetQuestions = async (request) => {
  return await _entityGetQuestions(baseUrl, request)
}
async function _entityCreateQuestion (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/entity/questions/`, {
    method: 'POST',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityCreateQuestion']} */
export const entityCreateQuestion = async (request) => {
  return await _entityCreateQuestion(baseUrl, request)
}
async function _entityUpdateQuestions (url, request) {
  const queryParameters = ['fields', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.description.eq', 'where.description.neq', 'where.description.gt', 'where.description.gte', 'where.description.lt', 'where.description.lte', 'where.description.like', 'where.description.in', 'where.description.nin', 'where.description.contains', 'where.description.contained', 'where.description.overlaps', 'where.examId.eq', 'where.examId.neq', 'where.examId.gt', 'where.examId.gte', 'where.examId.lt', 'where.examId.lte', 'where.examId.like', 'where.examId.in', 'where.examId.nin', 'where.examId.contains', 'where.examId.contained', 'where.examId.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.status.eq', 'where.status.neq', 'where.status.gt', 'where.status.gte', 'where.status.lt', 'where.status.lte', 'where.status.like', 'where.status.in', 'where.status.nin', 'where.status.contains', 'where.status.contained', 'where.status.overlaps', 'where.title.eq', 'where.title.neq', 'where.title.gt', 'where.title.gte', 'where.title.lt', 'where.title.lte', 'where.title.like', 'where.title.in', 'where.title.nin', 'where.title.contains', 'where.title.contained', 'where.title.overlaps', 'where.or']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/entity/questions/?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityUpdateQuestions']} */
export const entityUpdateQuestions = async (request) => {
  return await _entityUpdateQuestions(baseUrl, request)
}
async function _entityGetQuestionById (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/questions/${request['id']}?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetQuestionById']} */
export const entityGetQuestionById = async (request) => {
  return await _entityGetQuestionById(baseUrl, request)
}
async function _entityUpdateQuestion (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/entity/questions/${request['id']}?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityUpdateQuestion']} */
export const entityUpdateQuestion = async (request) => {
  return await _entityUpdateQuestion(baseUrl, request)
}
async function _entityDeleteQuestions (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/entity/questions/${request['id']}?${searchParams.toString()}`, {
    method: 'DELETE',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityDeleteQuestions']} */
export const entityDeleteQuestions = async (request) => {
  return await _entityDeleteQuestions(baseUrl, request)
}
async function _entityGetAnswersForQuestion (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/questions/${request['id']}/answers?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetAnswersForQuestion']} */
export const entityGetAnswersForQuestion = async (request) => {
  return await _entityGetAnswersForQuestion(baseUrl, request)
}
async function _entityGetExamineeExamAnswersForQuestion (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/questions/${request['id']}/examineeExamAnswerQuestionId?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetExamineeExamAnswersForQuestion']} */
export const entityGetExamineeExamAnswersForQuestion = async (request) => {
  return await _entityGetExamineeExamAnswersForQuestion(baseUrl, request)
}
async function _entityGetExamForQuestion (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/questions/${request['id']}/exam?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetExamForQuestion']} */
export const entityGetExamForQuestion = async (request) => {
  return await _entityGetExamForQuestion(baseUrl, request)
}
async function _entityGetAnswers (url, request) {
  const queryParameters = ['limit', 'offset', 'totalCount', 'fields', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.description.eq', 'where.description.neq', 'where.description.gt', 'where.description.gte', 'where.description.lt', 'where.description.lte', 'where.description.like', 'where.description.in', 'where.description.nin', 'where.description.contains', 'where.description.contained', 'where.description.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.questionId.eq', 'where.questionId.neq', 'where.questionId.gt', 'where.questionId.gte', 'where.questionId.lt', 'where.questionId.lte', 'where.questionId.like', 'where.questionId.in', 'where.questionId.nin', 'where.questionId.contains', 'where.questionId.contained', 'where.questionId.overlaps', 'where.or', 'orderby.createdAt', 'orderby.description', 'orderby.id', 'orderby.questionId']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/answers/?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetAnswers']} */
export const entityGetAnswers = async (request) => {
  return await _entityGetAnswers(baseUrl, request)
}
async function _entityCreateAnswer (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/entity/answers/`, {
    method: 'POST',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityCreateAnswer']} */
export const entityCreateAnswer = async (request) => {
  return await _entityCreateAnswer(baseUrl, request)
}
async function _entityUpdateAnswers (url, request) {
  const queryParameters = ['fields', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.description.eq', 'where.description.neq', 'where.description.gt', 'where.description.gte', 'where.description.lt', 'where.description.lte', 'where.description.like', 'where.description.in', 'where.description.nin', 'where.description.contains', 'where.description.contained', 'where.description.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.questionId.eq', 'where.questionId.neq', 'where.questionId.gt', 'where.questionId.gte', 'where.questionId.lt', 'where.questionId.lte', 'where.questionId.like', 'where.questionId.in', 'where.questionId.nin', 'where.questionId.contains', 'where.questionId.contained', 'where.questionId.overlaps', 'where.or']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/entity/answers/?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityUpdateAnswers']} */
export const entityUpdateAnswers = async (request) => {
  return await _entityUpdateAnswers(baseUrl, request)
}
async function _entityGetAnswerById (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/answers/${request['id']}?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetAnswerById']} */
export const entityGetAnswerById = async (request) => {
  return await _entityGetAnswerById(baseUrl, request)
}
async function _entityUpdateAnswer (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/entity/answers/${request['id']}?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityUpdateAnswer']} */
export const entityUpdateAnswer = async (request) => {
  return await _entityUpdateAnswer(baseUrl, request)
}
async function _entityDeleteAnswers (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/entity/answers/${request['id']}?${searchParams.toString()}`, {
    method: 'DELETE',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityDeleteAnswers']} */
export const entityDeleteAnswers = async (request) => {
  return await _entityDeleteAnswers(baseUrl, request)
}
async function _entityGetExamineeExamAnswersForAnswer (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/answers/${request['id']}/examineeExamAnswerAnswerId?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetExamineeExamAnswersForAnswer']} */
export const entityGetExamineeExamAnswersForAnswer = async (request) => {
  return await _entityGetExamineeExamAnswersForAnswer(baseUrl, request)
}
async function _entityGetQuestionForAnswer (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/answers/${request['id']}/question?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetQuestionForAnswer']} */
export const entityGetQuestionForAnswer = async (request) => {
  return await _entityGetQuestionForAnswer(baseUrl, request)
}
async function _entityGetExamineeExams (url, request) {
  const queryParameters = ['limit', 'offset', 'totalCount', 'fields', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.duration.eq', 'where.duration.neq', 'where.duration.gt', 'where.duration.gte', 'where.duration.lt', 'where.duration.lte', 'where.duration.like', 'where.duration.in', 'where.duration.nin', 'where.duration.contains', 'where.duration.contained', 'where.duration.overlaps', 'where.examId.eq', 'where.examId.neq', 'where.examId.gt', 'where.examId.gte', 'where.examId.lt', 'where.examId.lte', 'where.examId.like', 'where.examId.in', 'where.examId.nin', 'where.examId.contains', 'where.examId.contained', 'where.examId.overlaps', 'where.examineeId.eq', 'where.examineeId.neq', 'where.examineeId.gt', 'where.examineeId.gte', 'where.examineeId.lt', 'where.examineeId.lte', 'where.examineeId.like', 'where.examineeId.in', 'where.examineeId.nin', 'where.examineeId.contains', 'where.examineeId.contained', 'where.examineeId.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.startTime.eq', 'where.startTime.neq', 'where.startTime.gt', 'where.startTime.gte', 'where.startTime.lt', 'where.startTime.lte', 'where.startTime.like', 'where.startTime.in', 'where.startTime.nin', 'where.startTime.contains', 'where.startTime.contained', 'where.startTime.overlaps', 'where.status.eq', 'where.status.neq', 'where.status.gt', 'where.status.gte', 'where.status.lt', 'where.status.lte', 'where.status.like', 'where.status.in', 'where.status.nin', 'where.status.contains', 'where.status.contained', 'where.status.overlaps', 'where.or', 'orderby.createdAt', 'orderby.duration', 'orderby.examId', 'orderby.examineeId', 'orderby.id', 'orderby.startTime', 'orderby.status']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/examineeExams/?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetExamineeExams']} */
export const entityGetExamineeExams = async (request) => {
  return await _entityGetExamineeExams(baseUrl, request)
}
async function _entityCreateExamineeExam (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/entity/examineeExams/`, {
    method: 'POST',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityCreateExamineeExam']} */
export const entityCreateExamineeExam = async (request) => {
  return await _entityCreateExamineeExam(baseUrl, request)
}
async function _entityUpdateExamineeExams (url, request) {
  const queryParameters = ['fields', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.duration.eq', 'where.duration.neq', 'where.duration.gt', 'where.duration.gte', 'where.duration.lt', 'where.duration.lte', 'where.duration.like', 'where.duration.in', 'where.duration.nin', 'where.duration.contains', 'where.duration.contained', 'where.duration.overlaps', 'where.examId.eq', 'where.examId.neq', 'where.examId.gt', 'where.examId.gte', 'where.examId.lt', 'where.examId.lte', 'where.examId.like', 'where.examId.in', 'where.examId.nin', 'where.examId.contains', 'where.examId.contained', 'where.examId.overlaps', 'where.examineeId.eq', 'where.examineeId.neq', 'where.examineeId.gt', 'where.examineeId.gte', 'where.examineeId.lt', 'where.examineeId.lte', 'where.examineeId.like', 'where.examineeId.in', 'where.examineeId.nin', 'where.examineeId.contains', 'where.examineeId.contained', 'where.examineeId.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.startTime.eq', 'where.startTime.neq', 'where.startTime.gt', 'where.startTime.gte', 'where.startTime.lt', 'where.startTime.lte', 'where.startTime.like', 'where.startTime.in', 'where.startTime.nin', 'where.startTime.contains', 'where.startTime.contained', 'where.startTime.overlaps', 'where.status.eq', 'where.status.neq', 'where.status.gt', 'where.status.gte', 'where.status.lt', 'where.status.lte', 'where.status.like', 'where.status.in', 'where.status.nin', 'where.status.contains', 'where.status.contained', 'where.status.overlaps', 'where.or']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/entity/examineeExams/?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityUpdateExamineeExams']} */
export const entityUpdateExamineeExams = async (request) => {
  return await _entityUpdateExamineeExams(baseUrl, request)
}
async function _entityGetExamineeExamById (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/examineeExams/${request['id']}?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetExamineeExamById']} */
export const entityGetExamineeExamById = async (request) => {
  return await _entityGetExamineeExamById(baseUrl, request)
}
async function _entityUpdateExamineeExam (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/entity/examineeExams/${request['id']}?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityUpdateExamineeExam']} */
export const entityUpdateExamineeExam = async (request) => {
  return await _entityUpdateExamineeExam(baseUrl, request)
}
async function _entityDeleteExamineeExams (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/entity/examineeExams/${request['id']}?${searchParams.toString()}`, {
    method: 'DELETE',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityDeleteExamineeExams']} */
export const entityDeleteExamineeExams = async (request) => {
  return await _entityDeleteExamineeExams(baseUrl, request)
}
async function _entityGetExamineeExamAnswersForExamineeExam (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/examineeExams/${request['id']}/examineeExamAnswerExamineeExamId?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetExamineeExamAnswersForExamineeExam']} */
export const entityGetExamineeExamAnswersForExamineeExam = async (request) => {
  return await _entityGetExamineeExamAnswersForExamineeExam(baseUrl, request)
}
async function _entityGetUserForExamineeExam (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/examineeExams/${request['id']}/examinee?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetUserForExamineeExam']} */
export const entityGetUserForExamineeExam = async (request) => {
  return await _entityGetUserForExamineeExam(baseUrl, request)
}
async function _entityGetExamForExamineeExam (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/examineeExams/${request['id']}/exam?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetExamForExamineeExam']} */
export const entityGetExamForExamineeExam = async (request) => {
  return await _entityGetExamForExamineeExam(baseUrl, request)
}
async function _entityGetExamineeExamAnswers (url, request) {
  const queryParameters = ['limit', 'offset', 'totalCount', 'fields', 'where.answerId.eq', 'where.answerId.neq', 'where.answerId.gt', 'where.answerId.gte', 'where.answerId.lt', 'where.answerId.lte', 'where.answerId.like', 'where.answerId.in', 'where.answerId.nin', 'where.answerId.contains', 'where.answerId.contained', 'where.answerId.overlaps', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.examineeExamId.eq', 'where.examineeExamId.neq', 'where.examineeExamId.gt', 'where.examineeExamId.gte', 'where.examineeExamId.lt', 'where.examineeExamId.lte', 'where.examineeExamId.like', 'where.examineeExamId.in', 'where.examineeExamId.nin', 'where.examineeExamId.contains', 'where.examineeExamId.contained', 'where.examineeExamId.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.questionId.eq', 'where.questionId.neq', 'where.questionId.gt', 'where.questionId.gte', 'where.questionId.lt', 'where.questionId.lte', 'where.questionId.like', 'where.questionId.in', 'where.questionId.nin', 'where.questionId.contains', 'where.questionId.contained', 'where.questionId.overlaps', 'where.or', 'orderby.answerId', 'orderby.createdAt', 'orderby.examineeExamId', 'orderby.id', 'orderby.questionId']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/examineeExamAnswers/?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetExamineeExamAnswers']} */
export const entityGetExamineeExamAnswers = async (request) => {
  return await _entityGetExamineeExamAnswers(baseUrl, request)
}
async function _entityCreateExamineeExamAnswer (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/entity/examineeExamAnswers/`, {
    method: 'POST',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityCreateExamineeExamAnswer']} */
export const entityCreateExamineeExamAnswer = async (request) => {
  return await _entityCreateExamineeExamAnswer(baseUrl, request)
}
async function _entityUpdateExamineeExamAnswers (url, request) {
  const queryParameters = ['fields', 'where.answerId.eq', 'where.answerId.neq', 'where.answerId.gt', 'where.answerId.gte', 'where.answerId.lt', 'where.answerId.lte', 'where.answerId.like', 'where.answerId.in', 'where.answerId.nin', 'where.answerId.contains', 'where.answerId.contained', 'where.answerId.overlaps', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.examineeExamId.eq', 'where.examineeExamId.neq', 'where.examineeExamId.gt', 'where.examineeExamId.gte', 'where.examineeExamId.lt', 'where.examineeExamId.lte', 'where.examineeExamId.like', 'where.examineeExamId.in', 'where.examineeExamId.nin', 'where.examineeExamId.contains', 'where.examineeExamId.contained', 'where.examineeExamId.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.questionId.eq', 'where.questionId.neq', 'where.questionId.gt', 'where.questionId.gte', 'where.questionId.lt', 'where.questionId.lte', 'where.questionId.like', 'where.questionId.in', 'where.questionId.nin', 'where.questionId.contains', 'where.questionId.contained', 'where.questionId.overlaps', 'where.or']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/entity/examineeExamAnswers/?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityUpdateExamineeExamAnswers']} */
export const entityUpdateExamineeExamAnswers = async (request) => {
  return await _entityUpdateExamineeExamAnswers(baseUrl, request)
}
async function _entityGetExamineeExamAnswerById (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/examineeExamAnswers/${request['id']}?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetExamineeExamAnswerById']} */
export const entityGetExamineeExamAnswerById = async (request) => {
  return await _entityGetExamineeExamAnswerById(baseUrl, request)
}
async function _entityUpdateExamineeExamAnswer (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/entity/examineeExamAnswers/${request['id']}?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityUpdateExamineeExamAnswer']} */
export const entityUpdateExamineeExamAnswer = async (request) => {
  return await _entityUpdateExamineeExamAnswer(baseUrl, request)
}
async function _entityDeleteExamineeExamAnswers (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/entity/examineeExamAnswers/${request['id']}?${searchParams.toString()}`, {
    method: 'DELETE',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityDeleteExamineeExamAnswers']} */
export const entityDeleteExamineeExamAnswers = async (request) => {
  return await _entityDeleteExamineeExamAnswers(baseUrl, request)
}
async function _entityGetAnswerForExamineeExamAnswer (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/examineeExamAnswers/${request['id']}/answer?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetAnswerForExamineeExamAnswer']} */
export const entityGetAnswerForExamineeExamAnswer = async (request) => {
  return await _entityGetAnswerForExamineeExamAnswer(baseUrl, request)
}
async function _entityGetQuestionForExamineeExamAnswer (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/examineeExamAnswers/${request['id']}/question?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetQuestionForExamineeExamAnswer']} */
export const entityGetQuestionForExamineeExamAnswer = async (request) => {
  return await _entityGetQuestionForExamineeExamAnswer(baseUrl, request)
}
async function _entityGetExamineeExamForExamineeExamAnswer (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/examineeExamAnswers/${request['id']}/examinee_exam?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetExamineeExamForExamineeExamAnswer']} */
export const entityGetExamineeExamForExamineeExamAnswer = async (request) => {
  return await _entityGetExamineeExamForExamineeExamAnswer(baseUrl, request)
}
async function _postEntityLogin (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/entity/login`, {
    method: 'POST',
    body: JSON.stringify(request),
    headers
  })

  const textResponses = [200]
  if (textResponses.includes(response.status)) {
    return {
      statusCode: response.status,
      headers: headersToJSON(response.headers),
      body: await response.text()
    }
  }
  if (response.headers.get('content-type') === 'application/json') {
    return {
      statusCode: response.status,
      headers: headersToJSON(response.headers),
      body: await response.json()
    }
  }
  return {
    statusCode: response.status,
    headers: headersToJSON(response.headers),
    body: await response.text()
  }
}

/**  @type {import('./api-types.d.ts').Api['postEntityLogin']} */
export const postEntityLogin = async (request) => {
  return await _postEntityLogin(baseUrl, request)
}
async function _postEntitySignup (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/entity/signup`, {
    method: 'POST',
    body: JSON.stringify(request),
    headers
  })

  const textResponses = [200]
  if (textResponses.includes(response.status)) {
    return {
      statusCode: response.status,
      headers: headersToJSON(response.headers),
      body: await response.text()
    }
  }
  if (response.headers.get('content-type') === 'application/json') {
    return {
      statusCode: response.status,
      headers: headersToJSON(response.headers),
      body: await response.json()
    }
  }
  return {
    statusCode: response.status,
    headers: headersToJSON(response.headers),
    body: await response.text()
  }
}

/**  @type {import('./api-types.d.ts').Api['postEntitySignup']} */
export const postEntitySignup = async (request) => {
  return await _postEntitySignup(baseUrl, request)
}
async function _aiPrompt (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/ai/api/v1/prompt`, {
    method: 'POST',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['aiPrompt']} */
export const aiPrompt = async (request) => {
  return await _aiPrompt(baseUrl, request)
}
async function _aiStream (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/ai/api/v1/stream`, {
    method: 'POST',
    body: JSON.stringify(request),
    headers
  })

  const textResponses = [200]
  if (textResponses.includes(response.status)) {
    return {
      statusCode: response.status,
      headers: headersToJSON(response.headers),
      body: await response.text()
    }
  }
  if (response.headers.get('content-type') === 'application/json') {
    return {
      statusCode: response.status,
      headers: headersToJSON(response.headers),
      body: await response.json()
    }
  }
  return {
    statusCode: response.status,
    headers: headersToJSON(response.headers),
    body: await response.text()
  }
}

/**  @type {import('./api-types.d.ts').Api['aiStream']} */
export const aiStream = async (request) => {
  return await _aiStream(baseUrl, request)
}
export default function build (url, options) {
  url = sanitizeUrl(url)
  if (options?.headers) {
    defaultHeaders = options.headers
  }
  return {
    entityGetRoles: _entityGetRoles.bind(url, ...arguments),
    entityCreateRole: _entityCreateRole.bind(url, ...arguments),
    entityUpdateRoles: _entityUpdateRoles.bind(url, ...arguments),
    entityGetRoleById: _entityGetRoleById.bind(url, ...arguments),
    entityUpdateRole: _entityUpdateRole.bind(url, ...arguments),
    entityDeleteRoles: _entityDeleteRoles.bind(url, ...arguments),
    entityGetUsersForRole: _entityGetUsersForRole.bind(url, ...arguments),
    entityGetUsers: _entityGetUsers.bind(url, ...arguments),
    entityCreateUser: _entityCreateUser.bind(url, ...arguments),
    entityUpdateUsers: _entityUpdateUsers.bind(url, ...arguments),
    entityGetUserById: _entityGetUserById.bind(url, ...arguments),
    entityUpdateUser: _entityUpdateUser.bind(url, ...arguments),
    entityDeleteUsers: _entityDeleteUsers.bind(url, ...arguments),
    entityGetExamsForUser: _entityGetExamsForUser.bind(url, ...arguments),
    entityGetExamineeExamsForUser: _entityGetExamineeExamsForUser.bind(url, ...arguments),
    entityGetRoleForUser: _entityGetRoleForUser.bind(url, ...arguments),
    entityGetExams: _entityGetExams.bind(url, ...arguments),
    entityCreateExam: _entityCreateExam.bind(url, ...arguments),
    entityUpdateExams: _entityUpdateExams.bind(url, ...arguments),
    entityGetExamById: _entityGetExamById.bind(url, ...arguments),
    entityUpdateExam: _entityUpdateExam.bind(url, ...arguments),
    entityDeleteExams: _entityDeleteExams.bind(url, ...arguments),
    entityGetQuestionsForExam: _entityGetQuestionsForExam.bind(url, ...arguments),
    entityGetExamineeExamsForExam: _entityGetExamineeExamsForExam.bind(url, ...arguments),
    entityGetUserForExam: _entityGetUserForExam.bind(url, ...arguments),
    entityGetQuestions: _entityGetQuestions.bind(url, ...arguments),
    entityCreateQuestion: _entityCreateQuestion.bind(url, ...arguments),
    entityUpdateQuestions: _entityUpdateQuestions.bind(url, ...arguments),
    entityGetQuestionById: _entityGetQuestionById.bind(url, ...arguments),
    entityUpdateQuestion: _entityUpdateQuestion.bind(url, ...arguments),
    entityDeleteQuestions: _entityDeleteQuestions.bind(url, ...arguments),
    entityGetAnswersForQuestion: _entityGetAnswersForQuestion.bind(url, ...arguments),
    entityGetExamineeExamAnswersForQuestion: _entityGetExamineeExamAnswersForQuestion.bind(url, ...arguments),
    entityGetExamForQuestion: _entityGetExamForQuestion.bind(url, ...arguments),
    entityGetAnswers: _entityGetAnswers.bind(url, ...arguments),
    entityCreateAnswer: _entityCreateAnswer.bind(url, ...arguments),
    entityUpdateAnswers: _entityUpdateAnswers.bind(url, ...arguments),
    entityGetAnswerById: _entityGetAnswerById.bind(url, ...arguments),
    entityUpdateAnswer: _entityUpdateAnswer.bind(url, ...arguments),
    entityDeleteAnswers: _entityDeleteAnswers.bind(url, ...arguments),
    entityGetExamineeExamAnswersForAnswer: _entityGetExamineeExamAnswersForAnswer.bind(url, ...arguments),
    entityGetQuestionForAnswer: _entityGetQuestionForAnswer.bind(url, ...arguments),
    entityGetExamineeExams: _entityGetExamineeExams.bind(url, ...arguments),
    entityCreateExamineeExam: _entityCreateExamineeExam.bind(url, ...arguments),
    entityUpdateExamineeExams: _entityUpdateExamineeExams.bind(url, ...arguments),
    entityGetExamineeExamById: _entityGetExamineeExamById.bind(url, ...arguments),
    entityUpdateExamineeExam: _entityUpdateExamineeExam.bind(url, ...arguments),
    entityDeleteExamineeExams: _entityDeleteExamineeExams.bind(url, ...arguments),
    entityGetExamineeExamAnswersForExamineeExam: _entityGetExamineeExamAnswersForExamineeExam.bind(url, ...arguments),
    entityGetUserForExamineeExam: _entityGetUserForExamineeExam.bind(url, ...arguments),
    entityGetExamForExamineeExam: _entityGetExamForExamineeExam.bind(url, ...arguments),
    entityGetExamineeExamAnswers: _entityGetExamineeExamAnswers.bind(url, ...arguments),
    entityCreateExamineeExamAnswer: _entityCreateExamineeExamAnswer.bind(url, ...arguments),
    entityUpdateExamineeExamAnswers: _entityUpdateExamineeExamAnswers.bind(url, ...arguments),
    entityGetExamineeExamAnswerById: _entityGetExamineeExamAnswerById.bind(url, ...arguments),
    entityUpdateExamineeExamAnswer: _entityUpdateExamineeExamAnswer.bind(url, ...arguments),
    entityDeleteExamineeExamAnswers: _entityDeleteExamineeExamAnswers.bind(url, ...arguments),
    entityGetAnswerForExamineeExamAnswer: _entityGetAnswerForExamineeExamAnswer.bind(url, ...arguments),
    entityGetQuestionForExamineeExamAnswer: _entityGetQuestionForExamineeExamAnswer.bind(url, ...arguments),
    entityGetExamineeExamForExamineeExamAnswer: _entityGetExamineeExamForExamineeExamAnswer.bind(url, ...arguments),
    postEntityLogin: _postEntityLogin.bind(url, ...arguments),
    postEntitySignup: _postEntitySignup.bind(url, ...arguments),
    aiPrompt: _aiPrompt.bind(url, ...arguments),
    aiStream: _aiStream.bind(url, ...arguments)
  }
}