// This client was generated by Platformatic from an OpenAPI specification.

// The base URL for the API. This can be overridden by calling `setBaseUrl`.
let baseUrl = ''
// The default headers to send within each request. This can be overridden by calling `setDefaultHeaders`.
let defaultHeaders = {}

function sanitizeUrl(url) {
  if (url.endsWith('/')) { return url.slice(0, -1) } else { return url }
}
/**  @type {import('./api-types.d.ts').Api['setBaseUrl']} */
export const setBaseUrl = (newUrl) => { baseUrl = sanitizeUrl(newUrl) }

/**  @type {import('./api-types.d.ts').Api['setDefaultHeaders']} */
export const setDefaultHeaders = (headers) => { defaultHeaders = headers }

function headersToJSON(headers) {
  const output = {}
  headers.forEach((value, key) => {
    output[key] = value
  })
  return output
}

async function _entityGetRole (url, request) {
  const queryParameters = ['limit', 'offset', 'totalCount', 'fields', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.name.eq', 'where.name.neq', 'where.name.gt', 'where.name.gte', 'where.name.lt', 'where.name.lte', 'where.name.like', 'where.name.in', 'where.name.nin', 'where.name.contains', 'where.name.contained', 'where.name.overlaps', 'where.or', 'orderby.createdAt', 'orderby.id', 'orderby.name']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/role/?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetRole']} */
export const entityGetRole = async (request) => {
  return await _entityGetRole(baseUrl, request)
}
async function _entityCreateRole (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/entity/role/`, {
    method: 'POST',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityCreateRole']} */
export const entityCreateRole = async (request) => {
  return await _entityCreateRole(baseUrl, request)
}
async function _entityUpdateRole (url, request) {
  const queryParameters = ['fields', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.name.eq', 'where.name.neq', 'where.name.gt', 'where.name.gte', 'where.name.lt', 'where.name.lte', 'where.name.like', 'where.name.in', 'where.name.nin', 'where.name.contains', 'where.name.contained', 'where.name.overlaps', 'where.or']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/entity/role/?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityUpdateRole']} */
export const entityUpdateRole = async (request) => {
  return await _entityUpdateRole(baseUrl, request)
}
async function _entityGetRoleById (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/role/${request['id']}?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetRoleById']} */
export const entityGetRoleById = async (request) => {
  return await _entityGetRoleById(baseUrl, request)
}
async function _entityUpdateRole (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/entity/role/${request['id']}?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityUpdateRole']} */
export const entityUpdateRole = async (request) => {
  return await _entityUpdateRole(baseUrl, request)
}
async function _entityDeleteRole (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/entity/role/${request['id']}?${searchParams.toString()}`, {
    method: 'DELETE',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityDeleteRole']} */
export const entityDeleteRole = async (request) => {
  return await _entityDeleteRole(baseUrl, request)
}
async function _entityGetUserForRole (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/role/${request['id']}/user?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetUserForRole']} */
export const entityGetUserForRole = async (request) => {
  return await _entityGetUserForRole(baseUrl, request)
}
async function _entityGetUser (url, request) {
  const queryParameters = ['limit', 'offset', 'totalCount', 'fields', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.fullName.eq', 'where.fullName.neq', 'where.fullName.gt', 'where.fullName.gte', 'where.fullName.lt', 'where.fullName.lte', 'where.fullName.like', 'where.fullName.in', 'where.fullName.nin', 'where.fullName.contains', 'where.fullName.contained', 'where.fullName.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.password.eq', 'where.password.neq', 'where.password.gt', 'where.password.gte', 'where.password.lt', 'where.password.lte', 'where.password.like', 'where.password.in', 'where.password.nin', 'where.password.contains', 'where.password.contained', 'where.password.overlaps', 'where.role.eq', 'where.role.neq', 'where.role.gt', 'where.role.gte', 'where.role.lt', 'where.role.lte', 'where.role.like', 'where.role.in', 'where.role.nin', 'where.role.contains', 'where.role.contained', 'where.role.overlaps', 'where.username.eq', 'where.username.neq', 'where.username.gt', 'where.username.gte', 'where.username.lt', 'where.username.lte', 'where.username.like', 'where.username.in', 'where.username.nin', 'where.username.contains', 'where.username.contained', 'where.username.overlaps', 'where.or', 'orderby.createdAt', 'orderby.fullName', 'orderby.id', 'orderby.password', 'orderby.role', 'orderby.username']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/user/?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetUser']} */
export const entityGetUser = async (request) => {
  return await _entityGetUser(baseUrl, request)
}
async function _entityCreateUser (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/entity/user/`, {
    method: 'POST',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityCreateUser']} */
export const entityCreateUser = async (request) => {
  return await _entityCreateUser(baseUrl, request)
}
async function _entityUpdateUser (url, request) {
  const queryParameters = ['fields', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.fullName.eq', 'where.fullName.neq', 'where.fullName.gt', 'where.fullName.gte', 'where.fullName.lt', 'where.fullName.lte', 'where.fullName.like', 'where.fullName.in', 'where.fullName.nin', 'where.fullName.contains', 'where.fullName.contained', 'where.fullName.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.password.eq', 'where.password.neq', 'where.password.gt', 'where.password.gte', 'where.password.lt', 'where.password.lte', 'where.password.like', 'where.password.in', 'where.password.nin', 'where.password.contains', 'where.password.contained', 'where.password.overlaps', 'where.role.eq', 'where.role.neq', 'where.role.gt', 'where.role.gte', 'where.role.lt', 'where.role.lte', 'where.role.like', 'where.role.in', 'where.role.nin', 'where.role.contains', 'where.role.contained', 'where.role.overlaps', 'where.username.eq', 'where.username.neq', 'where.username.gt', 'where.username.gte', 'where.username.lt', 'where.username.lte', 'where.username.like', 'where.username.in', 'where.username.nin', 'where.username.contains', 'where.username.contained', 'where.username.overlaps', 'where.or']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/entity/user/?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityUpdateUser']} */
export const entityUpdateUser = async (request) => {
  return await _entityUpdateUser(baseUrl, request)
}
async function _entityGetUserById (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/user/${request['id']}?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetUserById']} */
export const entityGetUserById = async (request) => {
  return await _entityGetUserById(baseUrl, request)
}
async function _entityUpdateUser (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/entity/user/${request['id']}?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityUpdateUser']} */
export const entityUpdateUser = async (request) => {
  return await _entityUpdateUser(baseUrl, request)
}
async function _entityDeleteUser (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/entity/user/${request['id']}?${searchParams.toString()}`, {
    method: 'DELETE',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityDeleteUser']} */
export const entityDeleteUser = async (request) => {
  return await _entityDeleteUser(baseUrl, request)
}
async function _entityGetExamForUser (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/user/${request['id']}/exam?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetExamForUser']} */
export const entityGetExamForUser = async (request) => {
  return await _entityGetExamForUser(baseUrl, request)
}
async function _entityGetExamineeExamForUser (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/user/${request['id']}/examineeExamExamineeId?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetExamineeExamForUser']} */
export const entityGetExamineeExamForUser = async (request) => {
  return await _entityGetExamineeExamForUser(baseUrl, request)
}
async function _entityGetRoleForUser (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/user/${request['id']}/role?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetRoleForUser']} */
export const entityGetRoleForUser = async (request) => {
  return await _entityGetRoleForUser(baseUrl, request)
}
async function _entityGetExam (url, request) {
  const queryParameters = ['limit', 'offset', 'totalCount', 'fields', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.createdBy.eq', 'where.createdBy.neq', 'where.createdBy.gt', 'where.createdBy.gte', 'where.createdBy.lt', 'where.createdBy.lte', 'where.createdBy.like', 'where.createdBy.in', 'where.createdBy.nin', 'where.createdBy.contains', 'where.createdBy.contained', 'where.createdBy.overlaps', 'where.description.eq', 'where.description.neq', 'where.description.gt', 'where.description.gte', 'where.description.lt', 'where.description.lte', 'where.description.like', 'where.description.in', 'where.description.nin', 'where.description.contains', 'where.description.contained', 'where.description.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.status.eq', 'where.status.neq', 'where.status.gt', 'where.status.gte', 'where.status.lt', 'where.status.lte', 'where.status.like', 'where.status.in', 'where.status.nin', 'where.status.contains', 'where.status.contained', 'where.status.overlaps', 'where.title.eq', 'where.title.neq', 'where.title.gt', 'where.title.gte', 'where.title.lt', 'where.title.lte', 'where.title.like', 'where.title.in', 'where.title.nin', 'where.title.contains', 'where.title.contained', 'where.title.overlaps', 'where.or', 'orderby.createdAt', 'orderby.createdBy', 'orderby.description', 'orderby.id', 'orderby.status', 'orderby.title']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/exam/?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetExam']} */
export const entityGetExam = async (request) => {
  return await _entityGetExam(baseUrl, request)
}
async function _entityCreateExam (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/entity/exam/`, {
    method: 'POST',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityCreateExam']} */
export const entityCreateExam = async (request) => {
  return await _entityCreateExam(baseUrl, request)
}
async function _entityUpdateExam (url, request) {
  const queryParameters = ['fields', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.createdBy.eq', 'where.createdBy.neq', 'where.createdBy.gt', 'where.createdBy.gte', 'where.createdBy.lt', 'where.createdBy.lte', 'where.createdBy.like', 'where.createdBy.in', 'where.createdBy.nin', 'where.createdBy.contains', 'where.createdBy.contained', 'where.createdBy.overlaps', 'where.description.eq', 'where.description.neq', 'where.description.gt', 'where.description.gte', 'where.description.lt', 'where.description.lte', 'where.description.like', 'where.description.in', 'where.description.nin', 'where.description.contains', 'where.description.contained', 'where.description.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.status.eq', 'where.status.neq', 'where.status.gt', 'where.status.gte', 'where.status.lt', 'where.status.lte', 'where.status.like', 'where.status.in', 'where.status.nin', 'where.status.contains', 'where.status.contained', 'where.status.overlaps', 'where.title.eq', 'where.title.neq', 'where.title.gt', 'where.title.gte', 'where.title.lt', 'where.title.lte', 'where.title.like', 'where.title.in', 'where.title.nin', 'where.title.contains', 'where.title.contained', 'where.title.overlaps', 'where.or']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/entity/exam/?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityUpdateExam']} */
export const entityUpdateExam = async (request) => {
  return await _entityUpdateExam(baseUrl, request)
}
async function _entityGetExamById (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/exam/${request['id']}?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetExamById']} */
export const entityGetExamById = async (request) => {
  return await _entityGetExamById(baseUrl, request)
}
async function _entityUpdateExam (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/entity/exam/${request['id']}?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityUpdateExam']} */
export const entityUpdateExam = async (request) => {
  return await _entityUpdateExam(baseUrl, request)
}
async function _entityDeleteExam (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/entity/exam/${request['id']}?${searchParams.toString()}`, {
    method: 'DELETE',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityDeleteExam']} */
export const entityDeleteExam = async (request) => {
  return await _entityDeleteExam(baseUrl, request)
}
async function _entityGetQuestionForExam (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/exam/${request['id']}/question?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetQuestionForExam']} */
export const entityGetQuestionForExam = async (request) => {
  return await _entityGetQuestionForExam(baseUrl, request)
}
async function _entityGetExamineeExamForExam (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/exam/${request['id']}/examineeExamExamId?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetExamineeExamForExam']} */
export const entityGetExamineeExamForExam = async (request) => {
  return await _entityGetExamineeExamForExam(baseUrl, request)
}
async function _entityGetUserForExam (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/exam/${request['id']}/created_by?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetUserForExam']} */
export const entityGetUserForExam = async (request) => {
  return await _entityGetUserForExam(baseUrl, request)
}
async function _entityGetQuestion (url, request) {
  const queryParameters = ['limit', 'offset', 'totalCount', 'fields', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.description.eq', 'where.description.neq', 'where.description.gt', 'where.description.gte', 'where.description.lt', 'where.description.lte', 'where.description.like', 'where.description.in', 'where.description.nin', 'where.description.contains', 'where.description.contained', 'where.description.overlaps', 'where.examId.eq', 'where.examId.neq', 'where.examId.gt', 'where.examId.gte', 'where.examId.lt', 'where.examId.lte', 'where.examId.like', 'where.examId.in', 'where.examId.nin', 'where.examId.contains', 'where.examId.contained', 'where.examId.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.status.eq', 'where.status.neq', 'where.status.gt', 'where.status.gte', 'where.status.lt', 'where.status.lte', 'where.status.like', 'where.status.in', 'where.status.nin', 'where.status.contains', 'where.status.contained', 'where.status.overlaps', 'where.title.eq', 'where.title.neq', 'where.title.gt', 'where.title.gte', 'where.title.lt', 'where.title.lte', 'where.title.like', 'where.title.in', 'where.title.nin', 'where.title.contains', 'where.title.contained', 'where.title.overlaps', 'where.or', 'orderby.createdAt', 'orderby.description', 'orderby.examId', 'orderby.id', 'orderby.status', 'orderby.title']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/question/?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetQuestion']} */
export const entityGetQuestion = async (request) => {
  return await _entityGetQuestion(baseUrl, request)
}
async function _entityCreateQuestion (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/entity/question/`, {
    method: 'POST',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityCreateQuestion']} */
export const entityCreateQuestion = async (request) => {
  return await _entityCreateQuestion(baseUrl, request)
}
async function _entityUpdateQuestion (url, request) {
  const queryParameters = ['fields', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.description.eq', 'where.description.neq', 'where.description.gt', 'where.description.gte', 'where.description.lt', 'where.description.lte', 'where.description.like', 'where.description.in', 'where.description.nin', 'where.description.contains', 'where.description.contained', 'where.description.overlaps', 'where.examId.eq', 'where.examId.neq', 'where.examId.gt', 'where.examId.gte', 'where.examId.lt', 'where.examId.lte', 'where.examId.like', 'where.examId.in', 'where.examId.nin', 'where.examId.contains', 'where.examId.contained', 'where.examId.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.status.eq', 'where.status.neq', 'where.status.gt', 'where.status.gte', 'where.status.lt', 'where.status.lte', 'where.status.like', 'where.status.in', 'where.status.nin', 'where.status.contains', 'where.status.contained', 'where.status.overlaps', 'where.title.eq', 'where.title.neq', 'where.title.gt', 'where.title.gte', 'where.title.lt', 'where.title.lte', 'where.title.like', 'where.title.in', 'where.title.nin', 'where.title.contains', 'where.title.contained', 'where.title.overlaps', 'where.or']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/entity/question/?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityUpdateQuestion']} */
export const entityUpdateQuestion = async (request) => {
  return await _entityUpdateQuestion(baseUrl, request)
}
async function _entityGetQuestionById (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/question/${request['id']}?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetQuestionById']} */
export const entityGetQuestionById = async (request) => {
  return await _entityGetQuestionById(baseUrl, request)
}
async function _entityUpdateQuestion (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/entity/question/${request['id']}?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityUpdateQuestion']} */
export const entityUpdateQuestion = async (request) => {
  return await _entityUpdateQuestion(baseUrl, request)
}
async function _entityDeleteQuestion (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/entity/question/${request['id']}?${searchParams.toString()}`, {
    method: 'DELETE',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityDeleteQuestion']} */
export const entityDeleteQuestion = async (request) => {
  return await _entityDeleteQuestion(baseUrl, request)
}
async function _entityGetAnswerForQuestion (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/question/${request['id']}/answer?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetAnswerForQuestion']} */
export const entityGetAnswerForQuestion = async (request) => {
  return await _entityGetAnswerForQuestion(baseUrl, request)
}
async function _entityGetExamineeExamAnswerForQuestion (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/question/${request['id']}/examineeExamAnswerQuestionId?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetExamineeExamAnswerForQuestion']} */
export const entityGetExamineeExamAnswerForQuestion = async (request) => {
  return await _entityGetExamineeExamAnswerForQuestion(baseUrl, request)
}
async function _entityGetExamForQuestion (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/question/${request['id']}/exam?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetExamForQuestion']} */
export const entityGetExamForQuestion = async (request) => {
  return await _entityGetExamForQuestion(baseUrl, request)
}
async function _entityGetAnswer (url, request) {
  const queryParameters = ['limit', 'offset', 'totalCount', 'fields', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.description.eq', 'where.description.neq', 'where.description.gt', 'where.description.gte', 'where.description.lt', 'where.description.lte', 'where.description.like', 'where.description.in', 'where.description.nin', 'where.description.contains', 'where.description.contained', 'where.description.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.questionId.eq', 'where.questionId.neq', 'where.questionId.gt', 'where.questionId.gte', 'where.questionId.lt', 'where.questionId.lte', 'where.questionId.like', 'where.questionId.in', 'where.questionId.nin', 'where.questionId.contains', 'where.questionId.contained', 'where.questionId.overlaps', 'where.or', 'orderby.createdAt', 'orderby.description', 'orderby.id', 'orderby.questionId']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/answer/?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetAnswer']} */
export const entityGetAnswer = async (request) => {
  return await _entityGetAnswer(baseUrl, request)
}
async function _entityCreateAnswer (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/entity/answer/`, {
    method: 'POST',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityCreateAnswer']} */
export const entityCreateAnswer = async (request) => {
  return await _entityCreateAnswer(baseUrl, request)
}
async function _entityUpdateAnswer (url, request) {
  const queryParameters = ['fields', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.description.eq', 'where.description.neq', 'where.description.gt', 'where.description.gte', 'where.description.lt', 'where.description.lte', 'where.description.like', 'where.description.in', 'where.description.nin', 'where.description.contains', 'where.description.contained', 'where.description.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.questionId.eq', 'where.questionId.neq', 'where.questionId.gt', 'where.questionId.gte', 'where.questionId.lt', 'where.questionId.lte', 'where.questionId.like', 'where.questionId.in', 'where.questionId.nin', 'where.questionId.contains', 'where.questionId.contained', 'where.questionId.overlaps', 'where.or']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/entity/answer/?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityUpdateAnswer']} */
export const entityUpdateAnswer = async (request) => {
  return await _entityUpdateAnswer(baseUrl, request)
}
async function _entityGetAnswerById (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/answer/${request['id']}?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetAnswerById']} */
export const entityGetAnswerById = async (request) => {
  return await _entityGetAnswerById(baseUrl, request)
}
async function _entityUpdateAnswer (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/entity/answer/${request['id']}?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityUpdateAnswer']} */
export const entityUpdateAnswer = async (request) => {
  return await _entityUpdateAnswer(baseUrl, request)
}
async function _entityDeleteAnswer (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/entity/answer/${request['id']}?${searchParams.toString()}`, {
    method: 'DELETE',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityDeleteAnswer']} */
export const entityDeleteAnswer = async (request) => {
  return await _entityDeleteAnswer(baseUrl, request)
}
async function _entityGetExamineeExamAnswerForAnswer (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/answer/${request['id']}/examineeExamAnswerAnswerId?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetExamineeExamAnswerForAnswer']} */
export const entityGetExamineeExamAnswerForAnswer = async (request) => {
  return await _entityGetExamineeExamAnswerForAnswer(baseUrl, request)
}
async function _entityGetQuestionForAnswer (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/answer/${request['id']}/question?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetQuestionForAnswer']} */
export const entityGetQuestionForAnswer = async (request) => {
  return await _entityGetQuestionForAnswer(baseUrl, request)
}
async function _entityGetExamineeExam (url, request) {
  const queryParameters = ['limit', 'offset', 'totalCount', 'fields', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.duration.eq', 'where.duration.neq', 'where.duration.gt', 'where.duration.gte', 'where.duration.lt', 'where.duration.lte', 'where.duration.like', 'where.duration.in', 'where.duration.nin', 'where.duration.contains', 'where.duration.contained', 'where.duration.overlaps', 'where.examId.eq', 'where.examId.neq', 'where.examId.gt', 'where.examId.gte', 'where.examId.lt', 'where.examId.lte', 'where.examId.like', 'where.examId.in', 'where.examId.nin', 'where.examId.contains', 'where.examId.contained', 'where.examId.overlaps', 'where.examineeId.eq', 'where.examineeId.neq', 'where.examineeId.gt', 'where.examineeId.gte', 'where.examineeId.lt', 'where.examineeId.lte', 'where.examineeId.like', 'where.examineeId.in', 'where.examineeId.nin', 'where.examineeId.contains', 'where.examineeId.contained', 'where.examineeId.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.startTime.eq', 'where.startTime.neq', 'where.startTime.gt', 'where.startTime.gte', 'where.startTime.lt', 'where.startTime.lte', 'where.startTime.like', 'where.startTime.in', 'where.startTime.nin', 'where.startTime.contains', 'where.startTime.contained', 'where.startTime.overlaps', 'where.status.eq', 'where.status.neq', 'where.status.gt', 'where.status.gte', 'where.status.lt', 'where.status.lte', 'where.status.like', 'where.status.in', 'where.status.nin', 'where.status.contains', 'where.status.contained', 'where.status.overlaps', 'where.or', 'orderby.createdAt', 'orderby.duration', 'orderby.examId', 'orderby.examineeId', 'orderby.id', 'orderby.startTime', 'orderby.status']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/examineeExam/?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetExamineeExam']} */
export const entityGetExamineeExam = async (request) => {
  return await _entityGetExamineeExam(baseUrl, request)
}
async function _entityCreateExamineeExam (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/entity/examineeExam/`, {
    method: 'POST',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityCreateExamineeExam']} */
export const entityCreateExamineeExam = async (request) => {
  return await _entityCreateExamineeExam(baseUrl, request)
}
async function _entityUpdateExamineeExam (url, request) {
  const queryParameters = ['fields', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.duration.eq', 'where.duration.neq', 'where.duration.gt', 'where.duration.gte', 'where.duration.lt', 'where.duration.lte', 'where.duration.like', 'where.duration.in', 'where.duration.nin', 'where.duration.contains', 'where.duration.contained', 'where.duration.overlaps', 'where.examId.eq', 'where.examId.neq', 'where.examId.gt', 'where.examId.gte', 'where.examId.lt', 'where.examId.lte', 'where.examId.like', 'where.examId.in', 'where.examId.nin', 'where.examId.contains', 'where.examId.contained', 'where.examId.overlaps', 'where.examineeId.eq', 'where.examineeId.neq', 'where.examineeId.gt', 'where.examineeId.gte', 'where.examineeId.lt', 'where.examineeId.lte', 'where.examineeId.like', 'where.examineeId.in', 'where.examineeId.nin', 'where.examineeId.contains', 'where.examineeId.contained', 'where.examineeId.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.startTime.eq', 'where.startTime.neq', 'where.startTime.gt', 'where.startTime.gte', 'where.startTime.lt', 'where.startTime.lte', 'where.startTime.like', 'where.startTime.in', 'where.startTime.nin', 'where.startTime.contains', 'where.startTime.contained', 'where.startTime.overlaps', 'where.status.eq', 'where.status.neq', 'where.status.gt', 'where.status.gte', 'where.status.lt', 'where.status.lte', 'where.status.like', 'where.status.in', 'where.status.nin', 'where.status.contains', 'where.status.contained', 'where.status.overlaps', 'where.or']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/entity/examineeExam/?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityUpdateExamineeExam']} */
export const entityUpdateExamineeExam = async (request) => {
  return await _entityUpdateExamineeExam(baseUrl, request)
}
async function _entityGetExamineeExamById (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/examineeExam/${request['id']}?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetExamineeExamById']} */
export const entityGetExamineeExamById = async (request) => {
  return await _entityGetExamineeExamById(baseUrl, request)
}
async function _entityUpdateExamineeExam (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/entity/examineeExam/${request['id']}?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityUpdateExamineeExam']} */
export const entityUpdateExamineeExam = async (request) => {
  return await _entityUpdateExamineeExam(baseUrl, request)
}
async function _entityDeleteExamineeExam (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/entity/examineeExam/${request['id']}?${searchParams.toString()}`, {
    method: 'DELETE',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityDeleteExamineeExam']} */
export const entityDeleteExamineeExam = async (request) => {
  return await _entityDeleteExamineeExam(baseUrl, request)
}
async function _entityGetExamineeExamAnswerForExamineeExam (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/examineeExam/${request['id']}/examineeExamAnswerExamineeExamId?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetExamineeExamAnswerForExamineeExam']} */
export const entityGetExamineeExamAnswerForExamineeExam = async (request) => {
  return await _entityGetExamineeExamAnswerForExamineeExam(baseUrl, request)
}
async function _entityGetUserForExamineeExam (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/examineeExam/${request['id']}/examinee?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetUserForExamineeExam']} */
export const entityGetUserForExamineeExam = async (request) => {
  return await _entityGetUserForExamineeExam(baseUrl, request)
}
async function _entityGetExamForExamineeExam (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/examineeExam/${request['id']}/exam?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetExamForExamineeExam']} */
export const entityGetExamForExamineeExam = async (request) => {
  return await _entityGetExamForExamineeExam(baseUrl, request)
}
async function _entityGetExamineeExamAnswer (url, request) {
  const queryParameters = ['limit', 'offset', 'totalCount', 'fields', 'where.answerId.eq', 'where.answerId.neq', 'where.answerId.gt', 'where.answerId.gte', 'where.answerId.lt', 'where.answerId.lte', 'where.answerId.like', 'where.answerId.in', 'where.answerId.nin', 'where.answerId.contains', 'where.answerId.contained', 'where.answerId.overlaps', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.examineeExamId.eq', 'where.examineeExamId.neq', 'where.examineeExamId.gt', 'where.examineeExamId.gte', 'where.examineeExamId.lt', 'where.examineeExamId.lte', 'where.examineeExamId.like', 'where.examineeExamId.in', 'where.examineeExamId.nin', 'where.examineeExamId.contains', 'where.examineeExamId.contained', 'where.examineeExamId.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.questionId.eq', 'where.questionId.neq', 'where.questionId.gt', 'where.questionId.gte', 'where.questionId.lt', 'where.questionId.lte', 'where.questionId.like', 'where.questionId.in', 'where.questionId.nin', 'where.questionId.contains', 'where.questionId.contained', 'where.questionId.overlaps', 'where.or', 'orderby.answerId', 'orderby.createdAt', 'orderby.examineeExamId', 'orderby.id', 'orderby.questionId']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/examineeExamAnswer/?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetExamineeExamAnswer']} */
export const entityGetExamineeExamAnswer = async (request) => {
  return await _entityGetExamineeExamAnswer(baseUrl, request)
}
async function _entityCreateExamineeExamAnswer (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/entity/examineeExamAnswer/`, {
    method: 'POST',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityCreateExamineeExamAnswer']} */
export const entityCreateExamineeExamAnswer = async (request) => {
  return await _entityCreateExamineeExamAnswer(baseUrl, request)
}
async function _entityUpdateExamineeExamAnswer (url, request) {
  const queryParameters = ['fields', 'where.answerId.eq', 'where.answerId.neq', 'where.answerId.gt', 'where.answerId.gte', 'where.answerId.lt', 'where.answerId.lte', 'where.answerId.like', 'where.answerId.in', 'where.answerId.nin', 'where.answerId.contains', 'where.answerId.contained', 'where.answerId.overlaps', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.examineeExamId.eq', 'where.examineeExamId.neq', 'where.examineeExamId.gt', 'where.examineeExamId.gte', 'where.examineeExamId.lt', 'where.examineeExamId.lte', 'where.examineeExamId.like', 'where.examineeExamId.in', 'where.examineeExamId.nin', 'where.examineeExamId.contains', 'where.examineeExamId.contained', 'where.examineeExamId.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.questionId.eq', 'where.questionId.neq', 'where.questionId.gt', 'where.questionId.gte', 'where.questionId.lt', 'where.questionId.lte', 'where.questionId.like', 'where.questionId.in', 'where.questionId.nin', 'where.questionId.contains', 'where.questionId.contained', 'where.questionId.overlaps', 'where.or']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/entity/examineeExamAnswer/?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityUpdateExamineeExamAnswer']} */
export const entityUpdateExamineeExamAnswer = async (request) => {
  return await _entityUpdateExamineeExamAnswer(baseUrl, request)
}
async function _entityGetExamineeExamAnswerById (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/examineeExamAnswer/${request['id']}?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetExamineeExamAnswerById']} */
export const entityGetExamineeExamAnswerById = async (request) => {
  return await _entityGetExamineeExamAnswerById(baseUrl, request)
}
async function _entityUpdateExamineeExamAnswer (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/entity/examineeExamAnswer/${request['id']}?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityUpdateExamineeExamAnswer']} */
export const entityUpdateExamineeExamAnswer = async (request) => {
  return await _entityUpdateExamineeExamAnswer(baseUrl, request)
}
async function _entityDeleteExamineeExamAnswer (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/entity/examineeExamAnswer/${request['id']}?${searchParams.toString()}`, {
    method: 'DELETE',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityDeleteExamineeExamAnswer']} */
export const entityDeleteExamineeExamAnswer = async (request) => {
  return await _entityDeleteExamineeExamAnswer(baseUrl, request)
}
async function _entityGetAnswerForExamineeExamAnswer (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/examineeExamAnswer/${request['id']}/answer?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetAnswerForExamineeExamAnswer']} */
export const entityGetAnswerForExamineeExamAnswer = async (request) => {
  return await _entityGetAnswerForExamineeExamAnswer(baseUrl, request)
}
async function _entityGetQuestionForExamineeExamAnswer (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/examineeExamAnswer/${request['id']}/question?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetQuestionForExamineeExamAnswer']} */
export const entityGetQuestionForExamineeExamAnswer = async (request) => {
  return await _entityGetQuestionForExamineeExamAnswer(baseUrl, request)
}
async function _entityGetExamineeExamForExamineeExamAnswer (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/entity/examineeExamAnswer/${request['id']}/examinee_exam?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['entityGetExamineeExamForExamineeExamAnswer']} */
export const entityGetExamineeExamForExamineeExamAnswer = async (request) => {
  return await _entityGetExamineeExamForExamineeExamAnswer(baseUrl, request)
}
async function _postEntityLogin (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/entity/login`, {
    method: 'POST',
    body: JSON.stringify(request),
    headers
  })

  const textResponses = [200]
  if (textResponses.includes(response.status)) {
    return {
      statusCode: response.status,
      headers: headersToJSON(response.headers),
      body: await response.text()
    }
  }
  if (response.headers.get('content-type') === 'application/json') {
    return {
      statusCode: response.status,
      headers: headersToJSON(response.headers),
      body: await response.json()
    }
  }
  return {
    statusCode: response.status,
    headers: headersToJSON(response.headers),
    body: await response.text()
  }
}

/**  @type {import('./api-types.d.ts').Api['postEntityLogin']} */
export const postEntityLogin = async (request) => {
  return await _postEntityLogin(baseUrl, request)
}
async function _postEntitySignup (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/entity/signup`, {
    method: 'POST',
    body: JSON.stringify(request),
    headers
  })

  const textResponses = [200]
  if (textResponses.includes(response.status)) {
    return {
      statusCode: response.status,
      headers: headersToJSON(response.headers),
      body: await response.text()
    }
  }
  if (response.headers.get('content-type') === 'application/json') {
    return {
      statusCode: response.status,
      headers: headersToJSON(response.headers),
      body: await response.json()
    }
  }
  return {
    statusCode: response.status,
    headers: headersToJSON(response.headers),
    body: await response.text()
  }
}

/**  @type {import('./api-types.d.ts').Api['postEntitySignup']} */
export const postEntitySignup = async (request) => {
  return await _postEntitySignup(baseUrl, request)
}
async function _aiPrompt (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/ai/api/v1/prompt`, {
    method: 'POST',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./api-types.d.ts').Api['aiPrompt']} */
export const aiPrompt = async (request) => {
  return await _aiPrompt(baseUrl, request)
}
async function _aiStream (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/ai/api/v1/stream`, {
    method: 'POST',
    body: JSON.stringify(request),
    headers
  })

  const textResponses = [200]
  if (textResponses.includes(response.status)) {
    return {
      statusCode: response.status,
      headers: headersToJSON(response.headers),
      body: await response.text()
    }
  }
  if (response.headers.get('content-type') === 'application/json') {
    return {
      statusCode: response.status,
      headers: headersToJSON(response.headers),
      body: await response.json()
    }
  }
  return {
    statusCode: response.status,
    headers: headersToJSON(response.headers),
    body: await response.text()
  }
}

/**  @type {import('./api-types.d.ts').Api['aiStream']} */
export const aiStream = async (request) => {
  return await _aiStream(baseUrl, request)
}
export default function build (url, options) {
  url = sanitizeUrl(url)
  if (options?.headers) {
    defaultHeaders = options.headers
  }
  return {
    entityGetRole: _entityGetRole.bind(url, ...arguments),
    entityCreateRole: _entityCreateRole.bind(url, ...arguments),
    entityUpdateRole: _entityUpdateRole.bind(url, ...arguments),
    entityGetRoleById: _entityGetRoleById.bind(url, ...arguments),
    entityUpdateRole: _entityUpdateRole.bind(url, ...arguments),
    entityDeleteRole: _entityDeleteRole.bind(url, ...arguments),
    entityGetUserForRole: _entityGetUserForRole.bind(url, ...arguments),
    entityGetUser: _entityGetUser.bind(url, ...arguments),
    entityCreateUser: _entityCreateUser.bind(url, ...arguments),
    entityUpdateUser: _entityUpdateUser.bind(url, ...arguments),
    entityGetUserById: _entityGetUserById.bind(url, ...arguments),
    entityUpdateUser: _entityUpdateUser.bind(url, ...arguments),
    entityDeleteUser: _entityDeleteUser.bind(url, ...arguments),
    entityGetExamForUser: _entityGetExamForUser.bind(url, ...arguments),
    entityGetExamineeExamForUser: _entityGetExamineeExamForUser.bind(url, ...arguments),
    entityGetRoleForUser: _entityGetRoleForUser.bind(url, ...arguments),
    entityGetExam: _entityGetExam.bind(url, ...arguments),
    entityCreateExam: _entityCreateExam.bind(url, ...arguments),
    entityUpdateExam: _entityUpdateExam.bind(url, ...arguments),
    entityGetExamById: _entityGetExamById.bind(url, ...arguments),
    entityUpdateExam: _entityUpdateExam.bind(url, ...arguments),
    entityDeleteExam: _entityDeleteExam.bind(url, ...arguments),
    entityGetQuestionForExam: _entityGetQuestionForExam.bind(url, ...arguments),
    entityGetExamineeExamForExam: _entityGetExamineeExamForExam.bind(url, ...arguments),
    entityGetUserForExam: _entityGetUserForExam.bind(url, ...arguments),
    entityGetQuestion: _entityGetQuestion.bind(url, ...arguments),
    entityCreateQuestion: _entityCreateQuestion.bind(url, ...arguments),
    entityUpdateQuestion: _entityUpdateQuestion.bind(url, ...arguments),
    entityGetQuestionById: _entityGetQuestionById.bind(url, ...arguments),
    entityUpdateQuestion: _entityUpdateQuestion.bind(url, ...arguments),
    entityDeleteQuestion: _entityDeleteQuestion.bind(url, ...arguments),
    entityGetAnswerForQuestion: _entityGetAnswerForQuestion.bind(url, ...arguments),
    entityGetExamineeExamAnswerForQuestion: _entityGetExamineeExamAnswerForQuestion.bind(url, ...arguments),
    entityGetExamForQuestion: _entityGetExamForQuestion.bind(url, ...arguments),
    entityGetAnswer: _entityGetAnswer.bind(url, ...arguments),
    entityCreateAnswer: _entityCreateAnswer.bind(url, ...arguments),
    entityUpdateAnswer: _entityUpdateAnswer.bind(url, ...arguments),
    entityGetAnswerById: _entityGetAnswerById.bind(url, ...arguments),
    entityUpdateAnswer: _entityUpdateAnswer.bind(url, ...arguments),
    entityDeleteAnswer: _entityDeleteAnswer.bind(url, ...arguments),
    entityGetExamineeExamAnswerForAnswer: _entityGetExamineeExamAnswerForAnswer.bind(url, ...arguments),
    entityGetQuestionForAnswer: _entityGetQuestionForAnswer.bind(url, ...arguments),
    entityGetExamineeExam: _entityGetExamineeExam.bind(url, ...arguments),
    entityCreateExamineeExam: _entityCreateExamineeExam.bind(url, ...arguments),
    entityUpdateExamineeExam: _entityUpdateExamineeExam.bind(url, ...arguments),
    entityGetExamineeExamById: _entityGetExamineeExamById.bind(url, ...arguments),
    entityUpdateExamineeExam: _entityUpdateExamineeExam.bind(url, ...arguments),
    entityDeleteExamineeExam: _entityDeleteExamineeExam.bind(url, ...arguments),
    entityGetExamineeExamAnswerForExamineeExam: _entityGetExamineeExamAnswerForExamineeExam.bind(url, ...arguments),
    entityGetUserForExamineeExam: _entityGetUserForExamineeExam.bind(url, ...arguments),
    entityGetExamForExamineeExam: _entityGetExamForExamineeExam.bind(url, ...arguments),
    entityGetExamineeExamAnswer: _entityGetExamineeExamAnswer.bind(url, ...arguments),
    entityCreateExamineeExamAnswer: _entityCreateExamineeExamAnswer.bind(url, ...arguments),
    entityUpdateExamineeExamAnswer: _entityUpdateExamineeExamAnswer.bind(url, ...arguments),
    entityGetExamineeExamAnswerById: _entityGetExamineeExamAnswerById.bind(url, ...arguments),
    entityUpdateExamineeExamAnswer: _entityUpdateExamineeExamAnswer.bind(url, ...arguments),
    entityDeleteExamineeExamAnswer: _entityDeleteExamineeExamAnswer.bind(url, ...arguments),
    entityGetAnswerForExamineeExamAnswer: _entityGetAnswerForExamineeExamAnswer.bind(url, ...arguments),
    entityGetQuestionForExamineeExamAnswer: _entityGetQuestionForExamineeExamAnswer.bind(url, ...arguments),
    entityGetExamineeExamForExamineeExamAnswer: _entityGetExamineeExamForExamineeExamAnswer.bind(url, ...arguments),
    postEntityLogin: _postEntityLogin.bind(url, ...arguments),
    postEntitySignup: _postEntitySignup.bind(url, ...arguments),
    aiPrompt: _aiPrompt.bind(url, ...arguments),
    aiStream: _aiStream.bind(url, ...arguments)
  }
}